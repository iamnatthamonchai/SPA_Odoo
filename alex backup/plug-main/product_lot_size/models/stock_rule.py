
from collections import defaultdict
from dateutil.relativedelta import relativedelta
from odoo.osv import expression
from odoo.addons.stock.models.stock_rule import ProcurementException
from odoo import api, fields, models, SUPERUSER_ID, _
from odoo.tools.float_utils import float_compare
import logging

class MrpWorkcenter(models.Model):
    _inherit = 'mrp.workcenter'
    _order = "priority desc, sequence, id"

    priority = fields.Selection([
        ('0', 'Normal'),
        ('1', 'Important'),
    ], default='0', index=True, string="Starred")

class Mrpworkorder(models.Model):
    _inherit = 'mrp.workorder'
    _order = "priority desc"

    priority = fields.Selection([
        ('0', 'Normal'),
        ('1', 'Important'),
    ], default='0', index=True, string="Starred")

class MrpProduction(models.Model):
    """ Manufacturing Orders """
    _inherit = 'mrp.production'

    sale_line_id = fields.Many2one('sale.order.line', string="Origin Sale Order Line",copy=False)
    so_reference = fields.Char(string='SO Reference',related = 'sale_line_id.so_reference',store=True)
    so_line_sequence = fields.Integer(string='Sequence', default=1,copy=False)

    def action_generate_serial(self):
        self.ensure_one()
        if self.so_reference:
            name = self.so_reference +' - ' + str(self.so_line_sequence)

        else:
            name = self.env['stock.production.lot']._get_next_serial(self.company_id, self.product_id) or self.env['ir.sequence'].next_by_code('stock.lot.serial')

        self.lot_producing_id = self.env['stock.production.lot'].create({
            'product_id': self.product_id.id,
            'company_id': self.company_id.id,
            'name': name,
        })
        if self.move_finished_ids.filtered(lambda m: m.product_id == self.product_id).move_line_ids:
            self.move_finished_ids.filtered(lambda m: m.product_id == self.product_id).move_line_ids.lot_id = self.lot_producing_id
        if self.product_id.tracking == 'serial':
            self._set_qty_producing()
    
   
    def action_draft(self):
        self.workorder_ids.unlink()
        self._create_workorder()
        finish_moves = self.move_finished_ids.filtered(lambda x: x.state in ('cancel'))
        raw_moves = self.move_raw_ids.filtered(lambda x: x.state in ('cancel'))
        for move_line in finish_moves:
            move_line.update({'state' : 'draft'})
        finish_moves._recompute_state
        for move_line in raw_moves:
            move_line.update({'state' : 'draft'})
        raw_moves._recompute_state
        picking_ids = self.picking_ids.filtered(lambda x: x.state in ('cancel'))
        for picking in picking_ids:
            picking.update({'state' : 'draft'})
        self.update({'state' : ''})
        self._compute_state()
        return True

class SaleOrder(models.Model):
    _inherit = 'sale.order'

    @api.depends('procurement_group_id.stock_move_ids.created_production_id.procurement_group_id.mrp_production_ids','procurement_group_id.stock_move_ids')
    def _compute_mrp_production_count(self):
        data = self.env['procurement.group'].read_group([('sale_id', 'in', self.ids)], ['ids:array_agg(id)'], ['sale_id'])
        mrp_count = dict()
        for item in data:
            procurement_groups = self.env['procurement.group'].browse(item['ids'])
            mrp_count[item['sale_id'][0]] = len(
                set(procurement_groups.stock_move_ids.created_production_id.ids) |
                set(procurement_groups.mrp_production_ids.ids))
        for sale in self:
            production = self.env['mrp.production'].search([('origin', '=', sale.name)])
            if production:
                sale.mrp_production_count = len(production)
                count = 1
                for pro in production:
                    pro.write({'so_line_sequence':count})
                    count += 1
            else:
                sale.mrp_production_count = 0


    def action_view_mrp_production(self):
        self.ensure_one()
        procurement_groups = self.env['procurement.group'].search([('sale_id', 'in', self.ids)])
        production = self.env['mrp.production'].search([('origin', '=', self.name)])
        mrp_production_ids = set(procurement_groups.stock_move_ids.created_production_id.ids) |\
            set(procurement_groups.mrp_production_ids.ids)
        action = {
            'res_model': 'mrp.production',
            'type': 'ir.actions.act_window',
        }
        if len(mrp_production_ids) > 0:
            if len(mrp_production_ids) == 1:
                action.update({
                    'view_mode': 'form',
                    'res_id': mrp_production_ids.pop(),
                })
            else:
                action.update({
                    'name': _("Manufacturing Orders Generated by %s", self.name),
                    'domain': [('id', 'in', list(mrp_production_ids))],
                    'view_mode': 'tree,form',
                })
        else:
            if len(production) == 1:
                action.update({
                    'view_mode': 'form',
                    'res_id': production.id,
                })
            else:
                action.update({
                    'name': _("Manufacturing Orders Generated by %s", self.name),
                    'domain': [('id', 'in', production.ids)],
                    'view_mode': 'tree,form',
                })

        return action

class SaleOrderLine(models.Model):
    _inherit = 'sale.order.line'

    def _action_launch_stock_rule(self, previous_product_uom_qty=False):
        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
        procurements = []
        for line in self:
            line = line.with_company(line.company_id)
            if line.state != 'sale' or not line.product_id.type in ('consu','product'):
                continue
            qty = line._get_qty_procurement(previous_product_uom_qty)
            if float_compare(qty, line.product_uom_qty, precision_digits=precision) == 0:
                continue
            group_id = line._get_procurement_group()
            if not group_id:
                group_id = self.env['procurement.group'].create(line._prepare_procurement_group_vals())
                line.order_id.procurement_group_id = group_id
            else:
                # In case the procurement group is already created and the order was
                # cancelled, we need to update certain values of the group.
                updated_vals = {}
                if group_id.partner_id != line.order_id.partner_shipping_id:
                    updated_vals.update({'partner_id': line.order_id.partner_shipping_id.id})
                if group_id.move_type != line.order_id.picking_policy:
                    updated_vals.update({'move_type': line.order_id.picking_policy})
                if updated_vals:
                    group_id.write(updated_vals)

            values = line._prepare_procurement_values(group_id=group_id)
            product_qty = line.product_uom_qty - qty

            line_uom = line.product_uom
            quant_uom = line.product_id.uom_id
            product_qty, procurement_uom = line_uom._adjust_uom_quantities(product_qty, quant_uom)
            
            if line.product_id.product_lot_size > 0:
                qty_list = []
                divided_qty = int(product_qty / line.product_id.product_lot_size)  # 3
                modulo_qty = product_qty % line.product_id.product_lot_size  # 1
                count = 1
                for i in range(int(divided_qty)):
                    qty_list.append(line.product_id.product_lot_size)
                if int(divided_qty) > 0:
                    if modulo_qty > 0:
                        last_qty = line.product_id.product_lot_size * (50/100)
                        if modulo_qty > last_qty:
                            qty_list.append(modulo_qty)
                            modulo_qty = 0 
                else:
                    qty_list.append(modulo_qty)

                for each_qty in qty_list:
                    if count == divided_qty:
                        each_qty += modulo_qty
                    procurements.append(self.env['procurement.group'].Procurement(
                        line.product_id, each_qty, procurement_uom,
                        line.order_id.partner_shipping_id.property_stock_customer,
                        line.name, line.order_id.name, line.order_id.company_id, values))
                    count += 1
            else:
                procurements.append(self.env['procurement.group'].Procurement(
                    line.product_id, product_qty, procurement_uom,
                    line.order_id.partner_shipping_id.property_stock_customer,
                    line.name, line.order_id.name, line.order_id.company_id, values))
        if procurements:
            self.env['procurement.group'].run(procurements)

        # This next block is currently needed only because the scheduler trigger is done by picking confirmation rather than stock.move confirmation
        orders = self.mapped('order_id')
        for order in orders:
            pickings_to_confirm = order.picking_ids.filtered(lambda p: p.state not in ['cancel', 'done'])
            if pickings_to_confirm:
                # Trigger the Scheduler for Pickings
                pickings_to_confirm.action_confirm()
        return True
class StockRule(models.Model):
    _inherit = 'stock.rule'

    def _prepare_mo_vals(self, product_id, product_qty, product_uom, location_id, name, origin, company_id, values, bom):
        res = super()._prepare_mo_vals(product_id, product_qty, product_uom, location_id, name, origin, company_id, values, bom)
        if values.get('sale_line_id'):
            res['sale_line_id'] = values.get('sale_line_id')
        return res

    @api.model
    def _run_manufacture(self, procurements):
        productions_values_by_company = defaultdict(list)
        errors = []
        for procurement, rule in procurements:
            if float_compare(procurement.product_qty, 0, precision_rounding=procurement.product_uom.rounding) <= 0:
                # If procurement contains negative quantity, don't create a MO that would be for a negative value.
                continue
            bom = rule._get_matching_bom(procurement.product_id, procurement.company_id, procurement.values)

            productions_values_by_company[procurement.company_id.id].append(rule._prepare_mo_vals(*procurement, bom))

        if errors:
            raise ProcurementException(errors)

        for company_id, productions_values in productions_values_by_company.items():
            # create the MO as SUPERUSER because the current user may not have the rights to do it (mto product launched by a sale for example)
            productions = self.env['mrp.production'].with_user(SUPERUSER_ID).sudo().with_company(company_id).create(productions_values)
            self.env['stock.move'].sudo().create(productions._get_moves_raw_values())
            self.env['stock.move'].sudo().create(productions._get_moves_finished_values())
            productions._create_workorder()
            #productions.filtered(lambda p: not p.orderpoint_id).action_confirm()

            for production in productions:
                origin_production = production.move_dest_ids and production.move_dest_ids[0].raw_material_production_id or False
                orderpoint = production.orderpoint_id
                if orderpoint and orderpoint.create_uid.id == SUPERUSER_ID and orderpoint.trigger == 'manual':
                    production.message_post(
                        body=_('This production order has been created from Replenishment Report.'),
                        message_type='comment',
                        subtype_xmlid='mail.mt_note')
                elif orderpoint:
                    production.message_post_with_view(
                        'mail.message_origin_link',
                        values={'self': production, 'origin': orderpoint},
                        subtype_id=self.env.ref('mail.mt_note').id)
                elif origin_production:
                    production.message_post_with_view(
                        'mail.message_origin_link',
                        values={'self': production, 'origin': origin_production},
                        subtype_id=self.env.ref('mail.mt_note').id)
        return True